#!/usr/bin/python3
"""wavgen
A tool to generate signals with frequency components and write them to .wav files.

Usage:
    wavgen [--channels=CH] [--plot] FILE
    wavgen (-v | --version)
    wavgen (-h | --help)

Options:
    -h --help           Show this screen.
    -v --version        Show version.
    --channels=CH       Specifies the number of channels of the .wav file. [default: 1]
                        Channels are populated with the same data.
    --plot              Plot the signals.

Example:
    wavgen signal.wav
    wavgen --channels 2 --plot signal.wav
"""


import wave
import struct
import random 

try:
    from docopt import docopt
except ImportError:
    exit("This software refuses to run until docopt is installed:\n$ pip install docopt")

try:
    import numpy as np
except ImportError:
    exit("This software refuses to run until numpy is installed:\n$ pip install numpy")

try:
    import matplotlib.pyplot as plt
except ImportError:
    exit("This software refuses to run until matplotlib is installed:\n$ pip install matplotlib")

class sine:
    def __init__(self, amplitude=16384, frequency=50., phase=0., duration=1., rate=44100):
        self.a = abs(amplitude)
        self.f = frequency # hertz
        self.p = phase * np.pi / 180.0 # radians
        assert duration > 0
        self.d = duration # seconds
        assert rate > 0
        self.r = rate # samples per second
        self.t = np.arange(self.r * self.d) / self.r # time table based on duration and sampling rate
        self.__components = []

    def fundamental(self):
        return self.a * np.sin(2.0 * np.pi * self.f * self.t + self.p)

    def component(self, amplitude, frequency, phase):
        self.__components.append({'amplitude': amplitude, 'frequency': frequency, 'phase': phase * np.pi / 180.0})

    def components(self):
        return [c['amplitude'] * np.sin(2.0 * np.pi * c['frequency'] * self.t + c['phase']) for c in self.__components]

    def descriptors(self):
        return self.__components

    def time(self):
        return self.t

    def wave(self):
        wave = self.fundamental()
        for c in self.__components:
            component = c['amplitude'] * np.sin(2.0 * np.pi * c['frequency'] * self.t + c['phase'])
            wave = np.add(wave, component)
        return wave

    def rate(self):
        return self.r

def main(args):
    signal = sine(amplitude=16384, 
                  frequency=50, 
                  phase=90, 
                  duration=2.0, 
                  rate=31250)

    # Write signal to file
    wavef = wave.open(args['FILE'],'w')
    wavef.setnchannels(int(args['--channels'])) 
    wavef.setsampwidth(2) 
    wavef.setframerate(signal.rate())

    for f in range(9000, 11480, 80):
        ph = 90 * random.randrange(0, 3, 2)
        a = random.randrange(100, 300, 2)
        signal.component(a, f, ph)

    for sample in signal.wave():
        for channel in range(int(args['--channels'])):
            # little endian, short (2 byte)
            data = struct.pack('<h', int(sample))
            wavef.writeframesraw( data )

    wavef.writeframes(b'')
    wavef.close()
    
    if args['--plot'] is False:
        return 0

    # Plot signal
    plot1 = plt.subplot(3, 1, 1)
    plt.title('Sine with harmonics')
    plt.plot(signal.fundamental())
    plt.ylabel('Fundamental')

    plot2 = plt.subplot(3, 1, 2, sharex=plot1, sharey=plot1)
    d = signal.descriptors()
    for i, c in enumerate(signal.components()):
        plot2.plot(c, label='{} Hz, {} degrees'.format(d[i]['frequency'], np.ceil(d[i]['phase'] * 180 / np.pi )))
        plot2.legend()
    plt.ylabel('Harmonic')

    plt.subplot(3, 1, 3, sharex=plot1, sharey=plot1)
    plt.plot(signal.wave())
    plt.ylabel('Combined')

    plt.show()

if __name__ == "__main__":
    args = docopt(__doc__, version='0.1')
    main(args)
