#!/usr/bin/python3
import matplotlib.pyplot as plt
import numpy as np
import sys
import struct

def wav_file_read(filename):
    fi=open(filename,'rb')
    data=fi.read()
    fi.close()
    A, B, C, D    = struct.unpack('4c', data[0:4])      # 'RIFF'
    ChunkSize     = struct.unpack('<l', data[4:8])[0]   #4+(8+SubChunk1Size)+8+SubChunk2Size)
    A, B, C, D    = struct.unpack('4c', data[8:12])     # 'WAVE'
    A, B, C, D    = struct.unpack('4c', data[12:16])    # 'fmt '
    Subchunk1Size = struct.unpack('<l', data[16:20])[0] # LITTLE ENDIAN, long, 16
    AudioFormat   = struct.unpack('<h', data[20:22])[0] # LITTLE ENDIAN, short, 1
    NumChannels   = struct.unpack('<h', data[22:24])[0] # LITTLE ENDIAN, short, Mono = 1, Stereo = 2
    SampleRate    = struct.unpack('<l', data[24:28])[0] # LITTLE ENDIAN, long,  sample rate in samples per second
    ByteRate      = struct.unpack('<l', data[28:32])[0] # self.SampleRate * self.NumChannels * self.BitsPerSample/8)) # (ByteRate) LITTLE ENDIAN, long
    BlockAlign    = struct.unpack('<h', data[32:34])[0] # self.NumChannels * self.BitsPerSample/8))  # (BlockAlign) LITTLE ENDIAN, short
    BitsPerSample = struct.unpack('<h', data[34:36])[0] # LITTLE ENDIAN, short
    A, B, C, D    = struct.unpack('4c', data[36:40])    # BIG ENDIAN, char*4
    SubChunk2Size = struct.unpack('<l', data[40:44])[0] # LITTLE ENDIAN, long
    waveData=data[44:]

    print("%s\n\tChunkSize     = %d\n\tSubchunk1Size = %d\n\tAudioFormat   = %d\n\tNumChannels   = %d\n\tSampleRate    = %d\n\tByteRate      = %d\n\tBlockAlign    = %d\n\tBitsPerSample = %d\n\tSubChunk2Size = %d" %
        (filename,
        ChunkSize,
        Subchunk1Size, 
        AudioFormat,
        NumChannels,
        SampleRate,
        ByteRate,
        BlockAlign,
        BitsPerSample,
        SubChunk2Size))


    if BitsPerSample == 8:
        print("Unpacking %d bytes as 8 bits integers." % len(waveData))
        d = np.frombuffer(waveData, np.uint8)
    elif BitsPerSample == 16:
        print("Unpacking %d bytes as 16 bits integers." % len(waveData))
        d = np.zeros(int(SubChunk2Size / 2), dtype=np.int16)
        j = 0
        for k in range(0, SubChunk2Size, 2):
            d[j] = struct.unpack('<h', waveData[k:k+2])[0]
            j = j+1
    elif BitsPerSample == 24:
        print("Unpacking %d bytes as 24 bits integer." % len(waveData))
        d = np.zeros(SubChunk2Size/3,  dtype=np.int32)
        j = 0
        for k in range(0, SubChunk2Size, 3):
            d[j] = struct.unpack('<l', struct.pack('c', waveData[k]) + waveData[k:k+3])[0]
            j = j+1
    else: # anything else will be considered 32 bits
        if AudioFormat == 1:
            print("Unpacking %d bytes as 32 bits integer." % len(waveData))
            d = np.frombuffer(waveData, np.int32)
        elif AudioFormat == 3:
            print("Unpacking %d bytes as 32 bits float." % len(waveData))
            d = np.frombuffer(waveData, np.float32)

    v = d[0::NumChannels]
    for i in range(1,NumChannels):
        v = np.vstack((v, floatdata[i::NumChannels]))
    return v, SampleRate, NumChannels, BitsPerSample

if __name__ == "__main__":

    maxchannels = 0
    for n, f in enumerate(sys.argv[1:]):

        fig = plt.figure()

        signal, framerate, channels, BitsPerSample = wav_file_read(f)

        maxchannels = max(channels, maxchannels)

        # before looping, create the ax object required by sharex, sharey
        ax = fig.add_subplot(maxchannels, 1, 1)

        for channel in range(channels):
            ax = fig.add_subplot(maxchannels, 1, channel+1, sharex=ax, sharey=ax)
            ax.plot(signal[channel::channels], label=sys.argv[1+n] + ', channel ' + str(channel))
            plt.ylabel('Amplitude')
            plt.xlabel('Sample')

        plt.legend()

    plt.show()

